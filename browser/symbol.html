<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Symbol</title>
</head>
<body>
<script>
    (function () {
        /*let s = Symbol();
        console.log(typeof s);
        let s1 = Symbol('foo'),
            s2 = Symbol('bar');
        console.log(s1.toString());
        console.log(s2.toString());
        如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。
        let obj = {
            toString(){
                return "abc";
            }
        };
        let s = Symbol(obj);
        console.log(s);
        Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。
        let s1 = Symbol(),
            s2 = Symbol();
        console.log(s1 === s2);
        let s3 = Symbol('foo'),
            s4 = Symbol('foo');
        console.log(s3 === s4);
        Symbol 值不能与其他类型的值进行运算，但可显式转为字符串, 也可转为布尔值，但不能转为数值
        let s1 = Symbol('My symbol');
        "your symbol is " + s1;
        `your symbol is ${s1}`;*/

        //2. 作为属性名的Symbol
        /*let mySymbol = Symbol();
        //第一种写法
        let a = {};
        a[mySymbol] = 'Hello!';
        //第二种写法
        let b = {
            [mySymbol]: 'Hello!'
        };
        //第三种写法
        let c = {};
        Object.defineProperty(c, mySymbol,{value: 'Hello!'});
        console.log(a[mySymbol]);
        console.log(b[mySymbol]);
        console.log(c[mySymbol]);*/

        //4. 属性名的遍历
        /*let obj = {},
            a = Symbol('a'),
            b = Symbol('b');
        obj[a] = 'Hello';
        obj[b] = 'World';
        let objSymbols = Object.getOwnPropertySymbols(obj);
        console.log(objSymbols);
        let obj = {
            [Symbol('my_key')]: 1,
            enum: 2,
            nonEnum: 3
        };
        console.log(Reflect.ownKeys(obj));*/

        //5. Symbol.for()，Symbol.keyFor()
        /*let s1 = Symbol.for('foo'),
            s2 = Symbol.for('foo');
        console.log(s1 === s2);
        //Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key
        let s1 = Symbol.for('foo');
        console.log(Symbol.keyFor(s1));
        let s2 = Symbol('foo');
        console.log(Symbol.keyFor(s2));*/

        //Symbol.hasInstance
        /*class Even {
            static [Symbol.hasInstance](obj) {
                return Number(obj) % 2 === 0;
            }
        }
        //等同于
        const Evens = {
            [Symbol.hasInstance](obj) {
                return Number(obj) % 2 === 0;
            }
        };
        console.log(1 instanceOf Evens);
        console.log(2 instanceOf Evens);*/

        //Symbol.isConcatSpreadable
        let arr1 = ['c','d'];

    })()
</script>
</body>
</html>